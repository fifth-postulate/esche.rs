<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Esche.rs</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A book accompanying a workshop to recreate Escher's square limit.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        
        <link rel="stylesheet" href="geometry.css">
        

        
        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="title.html">Title</a></li><li class="affix"><a href="motivation.html">Motivation</a></li><li class="affix"><a href="grid.html">Grid method</a></li><li class="affix"><a href="box.html">Box</a></li><li><a href="turn.html"><strong aria-hidden="true">1.</strong> Turn</a></li><li><a href="flip.html"><strong aria-hidden="true">2.</strong> Flip</a></li><li><a href="picture.html"><strong aria-hidden="true">3.</strong> Picture</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title">Esche.rs</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#eschers" id="eschers"><h1>Esche.rs</h1></a>
<a class="header" href="print.html#exploring-functional-geometry" id="exploring-functional-geometry"><h2>Exploring functional geometry</h2></a>
<p><img src="https://uploads3.wikiart.org/images/m-c-escher/square-limit.jpg!Large.jpg" alt="Square Limit, Escher 1964" /></p>
<a class="header" href="print.html#motivation" id="motivation"><h1>Motivation</h1></a>
<p>It was the year 1982 when
<a href="https://www.ecs.soton.ac.uk/people/peter">Peter Henderson</a>, publishes a paper
called <em>Functional Geometry</em>. In it he describes an algebra of pictures that
allowed him to recreate <a href="https://en.wikipedia.org/wiki/M._C._Escher">Escher's</a>
<em>Square Limit</em>.</p>
<p><img src="https://uploads3.wikiart.org/images/m-c-escher/square-limit.jpg!Large.jpg" alt="Square Limit, Escher 1964" /></p>
<p>The 2002 reprint of <a href="https://eprints.soton.ac.uk/257577/1/funcgeo2.pdf">the article</a>
inspired <a href="https://einarwh.wordpress.com/">Einar Host</a> to give a
<a href="https://einarwh.wordpress.com/2017/07/22/picture-combinators-and-recursive-fish/">talk</a>
and a <a href="https://github.com/einarwh/escher-workshop">workshop</a>.</p>
<p>I was lucky enough to attend that workshop at
<a href="https://2018.boosterconf.no/">Booster Conf</a>. I had such a good time that I
translated the workshop to Rust.</p>
<p>I hope that you enjoy it as much as I did, when I first learned how to recreate
Escher's Square Limit in code.</p>
<a class="header" href="print.html#grid-method" id="grid-method"><h1>Grid method</h1></a>
<p>During the workshop we will be relying on a technique well know to painters. It
is called the <a href="https://www.art-is-fun.com/grid-method"><em>grid method</em></a>.</p>
<p>Let's explain this method with our t<strong>Rust</strong>ed logo.</p>
<p><img src="image/rust-logo-blk.svg" alt="The Rust logo" width="400px" height="400px"></p>
<p>The first thing we do to our logo is overlay a grid.</p>
<p><img src="image/grid-logo.svg" alt="A grid over the Rust logo" width="400px" height="400px"></p>
<p>Next we draw a second grid, similar to the first.</p>
<div class="reference">
  <img src="image/grid-logo.svg" alt="A grid over the Rust logo" width="400px" height="400px">
  <img src="image/grid.svg" alt="A single grid" width="400px" height="400px">
</div>
<p>Now we focus on a single cell in the original grid, and accurately copy it in
the corresponding grid in the target grid. Going from top to bottom and from
left to right, our first cell is empty. The second cell has a single tooth of
the gear. Let's copy it over.</p>
<div class="reference">
  <img src="image/grid-logo.svg" alt="A grid over the Rust logo" width="400px" height="400px">
  <img src="image/grid-logo-copy01.svg" alt="One cell copied of the Rust logo" width="400px" height="400px">
</div>
<p>The following cell has some more teeth.</p>
<div class="reference">
  <img src="image/grid-logo.svg" alt="A grid over the Rust logo" width="400px" height="400px">
  <img src="image/grid-logo-copy02.svg" alt="Two cells copied of the Rust logo" width="400px" height="400px">
</div>
<p>By copying each cell one by one, the original logo is recreated.</p>
<div class="reference">
  <img src="image/grid-logo.svg" alt="A grid over the Rust logo" width="400px" height="400px">
  <img src="image/grid-logo-copy03.svg" alt="Three cells copied of the Rust logo" width="400px" height="400px">
</div>
<p>until the original is completely copied.</p>
<div class="reference">
  <img src="image/grid-logo.svg" alt="A grid over the Rust logo" width="400px" height="400px">
  <img src="image/grid-logo.svg" alt="The Rust logo copied by the grid method" width="400px" height="400px">
</div>
<a class="header" href="print.html#variations" id="variations"><h2>Variations</h2></a>
<p>Once we understand the basics of the grid method, we can start to look for
variations. Nobody is restricting you to draw the target grid differently.</p>
<a class="header" href="print.html#scale" id="scale"><h3>Scale</h3></a>
<p>We could scale the grid.</p>
<div class="reference">
  <img src="image/grid-logo.svg" alt="A grid over the Rust logo" width="400px" height="400px">
  <img src="image/grid-logo-scaled.svg" alt="The Rust logo scaled by the grid method" width="400px" height="400px">
</div>
<a class="header" href="print.html#non-uniform-scale" id="non-uniform-scale"><h3>Non-uniform scale</h3></a>
<p>We could scale the grid non-uniformly.</p>
<div class="reference">
  <img src="image/grid-logo.svg" alt="A grid over the Rust logo" width="400px" height="400px">
  <img src="image/grid-logo-non-uniformly-scaled.svg" alt="The Rust logo scaled by the grid method" width="400px" height="400px">
</div>
<a class="header" href="print.html#shearing" id="shearing"><h3>Shearing</h3></a>
<p>We could shear the grid.</p>
<div class="reference">
  <img src="image/grid-logo.svg" alt="A grid over the Rust logo" width="400px" height="400px">
  <img src="image/grid-logo-shear.svg" alt="The Rust logo scaled by the grid method" width="400px" height="400px">
</div>
<a class="header" href="print.html#combination" id="combination"><h3>Combination</h3></a>
<p>Or we could combine various transformation and apply that to the grid.</p>
<div class="reference">
  <img src="image/grid-logo.svg" alt="A grid over the Rust logo" width="400px" height="400px">
  <img src="image/grid-logo-combination.svg" alt="The Rust logo scaled by the grid method" width="400px" height="400px">
</div>
<p>Because we will make extensive use of the grid method, and want to easily
manipulate the grid, we will introduce a <em>box</em> abstraction.</p>
<a class="header" href="print.html#box" id="box"><h1>Box</h1></a>
<p>We learned about <em>the grid method</em>. It allows us to instruct an artist that
knows how to copy a picture from a grid, how we want the picture copied. This can
be achieved by controlling the grid the artist will copy the picture into. The
grid method relies on a box. So we better should get to know our boxes.</p>
<p><img src="image/box.svg" alt="The standard box for reference" width="400px" height="400px"></p>
<p>Above you find a pictorial representation of a <em>box</em>. It is defined by three
vectors, <code>a</code>, which is red in the picture, <code>b</code> which is orange in the picture
and <code>c</code> which is purple in the picture.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// A Box represents the area and position that we will draw in.
#[derive(Debug, PartialEq, Clone, Copy)]
pub struct Box {
    /// Determines the origin of the drawing area, used to position the box.
    pub a: Vector&lt;f64&gt;,
    /// Determines the x axis of the box.
    pub b: Vector&lt;f64&gt;,
    /// Determines the y axis of the box.
    pub c: Vector&lt;f64&gt;,
}
#}</code></pre></pre>
<p>The above <code>struct</code> is a literal conversion from the picture. If you are
wondering what these <code>Vector</code>s are, take a look at the
<a href="doc/eschers/index.html">documentation</a>.</p>
<a class="header" href="print.html#turn" id="turn"><h1>Turn</h1></a>
<p><img src="image/d_turned.svg" alt="The letter d turned" width="400px" height="400px"></p>
<p>Our goal is to turn our letter through ninety degrees. As explained in the
background chapter we are going to do this by rotating the box. This way the
picture will be drawn turned automatically.</p>
<p>Here we see our goal box on the right, and the reference box on the left. Let's
figure out the relations between the new box fields <code>a</code>, <code>b</code> and <code>c</code> and the
reference box fields <code>a</code>, <code>b</code>, <code>c</code>.</p>
<div class="reference">
  <img src="image/box.svg" alt="The standard box for reference" width="400px" height="400px">
  <img src="image/box_turned.svg" alt="The standard box turned" width="400px" height="400px">
</div>
<p>Notice that for the target box the <code>a</code> field is the sum of the original box <code>a</code>
and <code>b</code> field.</p>
<p><img src="image/vector_sum.svg" alt="Vector sum of a and b" width="400px"
height="400px"></p>
<p>The new <code>b</code> is the original <code>c</code> and the new <code>c</code> is the original <code>b</code> negated.</p>
<a class="header" href="print.html#implement" id="implement"><h2>Implement</h2></a>
<p>Open <code>src/canvas/mod.rs</code> and find the <code>turn_box</code> function. At the moment it is
implemented by calling the identity function on its argument</p>
<pre><code>identity(&amp;bx)
</code></pre>
<p>We need to change that and return a turned box. <code>Box</code> has a constructor called
<code>new</code>. When provided with three <code>Vector</code> arguments it will a create a box with
the corresponding fields.</p>
<p>Take a look at the documentation for <code>Vector</code> in order to figure out how to do
vector addition and vector negation.</p>
<p>Having done that, try to implement the <code>turn_box</code> function correctly. You can
test your function by running <code>geometry</code> binary.</p>
<pre><code class="language-shell">cargo run --bin geometry
</code></pre>
<p>This should produce an <code>output.svg</code> and if you implemented <code>turn_box</code> correctly
should show the letter d turned.</p>
<a class="header" href="print.html#flip" id="flip"><h1>Flip</h1></a>
<p><img src="image/d_flipped.svg" alt="The letter d flipped" width="400px" height="400px"></p>
<p>Now our new goal is to flip our letter. Just as for the turned picture, we are
going to do this by flipping the box. For the next few chapters this will be our
goal; finding a target box.</p>
<p>Again, we see our goal box on the right, and the reference box on the left. Let's
figure out the relations between the new box fields <code>a</code>, <code>b</code> and <code>c</code> and the
reference box fields <code>a</code>, <code>b</code>, <code>c</code>.</p>
<div class="reference">
  <img src="image/box.svg" alt="The standard box for reference" width="400px" height="400px">
  <img src="image/box_flipped.svg" alt="The standard box flipped" width="400px" height="400px">
</div>
<p>Notice that for the target box the <code>a</code> field is again the sum of the original box <code>a</code>
and <code>b</code> field.</p>
<p><img src="image/vector_sum.svg" alt="Vector sum of a and b" width="400px"
height="400px"></p>
<p>The new <code>b</code> is the original <code>b</code> negated and the new <code>c</code> is the original <code>c</code>.</p>
<a class="header" href="print.html#implement-1" id="implement-1"><h2>Implement</h2></a>
<p>Open <code>src/canvas/mod.rs</code> and find the <code>flip_box</code> function. Just like the
<code>turn_box</code> function before, it is implemented by calling the identity function
on its argument</p>
<pre><code>identity(&amp;bx)
</code></pre>
<p>We need to change that and return a flipped box. It is very is very similar to
the <code>turn_box</code> function, so a good start is to copy that body and change it.</p>
<p>Testing your function is a little bit more involved now. Early you could run
<code>geometry</code> binary. Below you can find the <code>main</code> function of the <code>geometry</code>
binary.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let bx = Bx::new(
    Vector::new(0f64, 0f64),
    Vector::new(400f64, 0f64),
    Vector::new(0f64, 400f64)
);
let shapes = letter::d();
let source = create_picture(shapes);
let picture = turn(source);
let document = to_svg((400f64, 400f64), &amp;picture(&amp;bx));
svg::save(&quot;output.svg&quot;, &amp;document).unwrap();
#}</code></pre></pre>
<p>The line to look out for is the <code>let picture</code> line. Here we call the function
<code>turn</code> on our source shape. This function is found in the <code>picture</code> module. The
<code>turn</code> function is reproduced here.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn turn&lt;Picture&gt;(picture: Rc&lt;Picture&gt;) -&gt; Rc&lt;impl Fn(&amp;Bx) -&gt; Rendering&gt;
where Picture: Fn(&amp;Bx) -&gt; Rendering{
    let p = picture.clone();
    Rc::new(move |bx: &amp;Bx| {
        let turned_box = turn_box(&amp;bx);
        p(&amp;turned_box)
    })
}
#}</code></pre></pre>
<p>Whoah, look at that signature! It is wild! Take a deep breath, we will look will
explain the signature in a moment. The important parts, the part that turns the
picture is nicely tucked away.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let turned_box = turn_box(&amp;bx);
p(&amp;turned_box)
#}</code></pre></pre>
<p>Here we recognize our <code>turn_box</code> function, returning a <code>turned_box</code> which is
passed as an argument to what ever <code>p</code> is.</p>
<p>There is a lot going on besides that in the turn picture, but a lot of it is
boilerplate. We will explain that shortly. For now just copy the body of the
<code>turn</code> function, replace the body of the <code>flip</code> function with the copy and alter
it to use your <code>flip_box</code> function instead.</p>
<p>This takes care of the <code>flip</code> function, but it still needs to be called. Open
the <code>geometry</code> binary and change the <code>let picture</code> to call <code>flip</code> instead of
<code>turn</code> on the source.</p>
<p>If every thing worked out just fine, you should be able to run <code>geomtry</code> with
the following command</p>
<pre><code class="language-shell">cargo run --bin geometry
</code></pre>
<p>and find a flipped letter d in <code>output.svg</code>.</p>
<a class="header" href="print.html#picture" id="picture"><h1>Picture</h1></a>
<p>In the last chapter we looked at the interesting signature of the <code>turn</code>
function. We will repeated it here.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn turn&lt;Picture&gt;(picture: Rc&lt;Picture&gt;) -&gt; Rc&lt;impl Fn(&amp;Bx) -&gt; Rendering&gt;
where Picture: Fn(&amp;Bx) -&gt; Rendering 
#}</code></pre></pre>
<p>There is a lot going on. There is even a piece of information missing. I.e.
<code>Rendering</code> is a type alias.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub type Rendering = Vec&lt;(Shape, Style)&gt;;
#}</code></pre></pre>
<p>Let's take some time to think and see what this signature is all about.</p>
<a class="header" href="print.html#shape--style" id="shape--style"><h2>Shape &amp; Style</h2></a>
<p><code>Shape</code> are primitive drawing instructions. Various sort of lines and
instructions where to place them. If you are really curious you can take a look
at the <a href="http://localhost:3000/doc/eschers/shape/enum.Shape.html">documentation</a>.</p>
<p>The basic shapes are used to provide more abstract drawing instructions such as
letters or grids.</p>
<p><a href="http://localhost:3000/doc/eschers/style/struct.Style.html"><code>Style</code></a> instructs
an artist with which style to draw the shapes.</p>
<p>We will treat <code>Shape</code> and <code>Style</code>, and their derivatives, as black boxes. We
will use them as is, without further inspection.</p>
<a class="header" href="print.html#rendering" id="rendering"><h2>Rendering</h2></a>
<p>Single stroke art is a thing, but in general art is made with more elements. A
<code>Rendering</code> is just that, a sequences of shapes drawn with a certain style.</p>
<p><code>Rendering</code> is a
<a href="https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#type-aliases-create-type-synonyms"><em>type alias</em></a>.
It offers a nice shorthand for a type expression, but is otherwise
interchangeable with the long form.</p>
<p>Here is the definition</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub type Rendering = Vec&lt;(Shape, Style)&gt;;
#}</code></pre></pre>
<a class="header" href="print.html#picture-1" id="picture-1"><h2>Picture</h2></a>
<p>Let's take a look at an other alias, this time defined in the signature of the
<code>turn</code> function. For reference we repeat the definition below.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
where Picture: Fn(&amp;Bx) -&gt; Rendering
#}</code></pre></pre>
<p>A picture is a function that borrows a box, the one defined a few chapters back,
and returns a <code>Rendering</code>, i.e. a sequence of shapes to draw.</p>
<p>This is the most important abstraction that we will introduce. All following
types are in place to make these abstraction usable and safe.</p>
<a class="header" href="print.html#rc" id="rc"><h2>Rc</h2></a>
<p>It you take a look at the type signature of <code>turn</code> you will notice that the
<code>Picture</code> is wrapped in a <code>Rc</code>. It is a</p>
<blockquote>
<p>A single-threaded reference-counting pointer.</p>
</blockquote>
<p>As can be seen from the <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code> documentation</a>.</p>
<p>The reason we need a reference counting pointer to the <code>Picture</code> here is
two-fold.</p>
<a class="header" href="print.html#picture-can-not-be-owned" id="picture-can-not-be-owned"><h3>Picture can not be owned</h3></a>
<p>The first reason we need an reference counting pointer to the <code>Picture</code> is that
we might want to reuse the picture. If you look back at Eschers square limit,
you could see a lot of repetition in the image. As if a stamp is used to create
the collage of fishes.</p>
<p>This means that we can not take owner ship of <code>Picture</code>, because otherwise other
parts of our program can not reuse it.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
